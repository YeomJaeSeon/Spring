# Provider로 request 스코프 HTTP요청들어올때 생성해서 제대로 사용했다.

- 이것도 귀찮은 개발자는 프록시라는 방법으로 Provider로 DL할 객체를 의존관계주입해놓는게 아닌 그냥 기존에 하던것처럼, 싱글톤 스코프 빈 의존관계 주입하는것처럼하고 요청이들어오면 진짜 빈 사용할수있도록 하였다.

```
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
```

- 이렇게 `@Scope`에 proxyMode를 준다.
- 이렇게 되면 MyLogger의 가짜 프록시 클래스를 만들어두고 가짜 프폴시 클래스의 빈을 미리 주입해둘수있따.(HTTP요청이들어와야 생성되는 request빈이아님. 가짜임)
- 그러다 진짜 요청이들어오면 가짜빈이랑 진짜 빈이랑 바꿔치기해서 제대로 사용하는것이다.
- 프록시를 이용하면 DL하는 Provider객체를 의존하는게아닌 진짜 사용할 request 스코프 빈 을 의존하고있다가(사실 가짜 객체)진짜 HTTP요청이들어오면 진짜 request 스코프 빈 생성해서 바꿔치기하는것이다.

# 중요한점

- Provider객체를 의존하던가 가짜 프록시 객체를 의존하던가 의 중요한점은 실제로 진짜 HTTP요청이들어오면 request 스코프 빈이 생성되므로 진짜 request 스코프 빈을 지연 처리한다는점이다. 컨테이너 생성될떄는 어짜피 request스코프 빈이 존재하지않으므로 그떄까지 프록시로 버티던, DL객체로 버티던 하는것이다.
- 그리고 이러한 request 스코프 빈은 꼭 필요한곳에서만 사용하는게좋다. 그렇지 않으면 어? 왜여긴 빈이 없지,, 왜에러나지 이런 유지보수에 좋지않다. 특히 프록시를 이용하면 싱글톤처럼 존재하는것같으나 내부적으론 실제 요청이들어오면 그떄서야 진짜 request스코프 빈이랑 바꿔치기하는 내부 로직이 실행되기에 주의해서 사용해야한다.
