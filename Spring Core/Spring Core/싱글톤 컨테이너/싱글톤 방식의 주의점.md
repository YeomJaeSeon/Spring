# 싱글톤 방식의 주의점

- 싱글톤 으로 객체인스턴스 하나만 사용하고 그 하나를 공유해서 사용할땐 정말 주의해야한다.
- 왜? 서비스를 이용하는 모든 클라이언트가 해당 객체 인스턴스 하나를 다 공유해서 사용하기때문에 해당 인스턴스의 멤버변수의 값을 변경하면 다른 엄한 클라이언트들도 적용이 되기때문이다.
- 그래서 싱글턴 객체 인스턴스의 멤버변수는 절대 변경할수있으면 안된다.
- 엄청나게 심각한 오류를 가져올수있다.

# 싱글톤 객체 인스턴스의 멤버변수를 수정할수있을경우

```
public class StateFulService {
    private int price;
    public void order(String name, int price){
        System.out.println("name = " + name + " price = " + price);
        this.price = price;
    }

    public int getPrice(){
        return price;
    }

}
```

- StateFulService 객체를 스프링빈으로등록할거임. 그러면 싱글톤 객체로 존재하겠다. 그런데 이 객체인스턴스의 멤버변수 `price`를 변경할수있게 해버리면(`order`메서드 내에서 변경가능하지..?) 엄청나게 심각한오류를 범한다.
- 클라이언트 A가 1000원의 파라미터를 넘기며 요청한뒤 클라이언트 B가 2000원의 파라미터를 넘기며 요청하면 하나의 객체인스턴스(스프링빈)의 멤버변수 price는 2000원이되어버린다. 클라이언트 A는 2000원이 결제될수도있음..!!! - 너무너무심각한오류다.

- 그래서 스프링 빈같은 싱글턴 객체인스턴스는 상태를 유지하는 멤버변수를 절대사용하면안된다.(클라이언트에 의존적인 멤버변수를 사용하면 안된다.)
- 간단하게 지역변수를 이용해서라도 클라이언트에 의존적인 멤버변수를 사용하면안됨

# 해결 코드

```
public class StatelessService {
    // 상태를 유지하는 멤버변수대신 지역변수를 이용하자. 싱글턴 객체는 상태유지하는 필드 쓰면 절대안됨.
    public int order(String itemName, int price){
        System.out.println("itemName : " + itemName + " price : " + price);
        return price;
    }
}
```

- StatelessService 객체 인스턴스를 스프링빈으로 등록하여 싱글턴 객체 인스턴스로 가지고있어도 클라이언트에 의존적인, 클라이언트가 변경할수있는 필드가 없으므로 공유 인스턴스를 써도 혼란을 야기하지 않음!

# 결론

- 싱글턴 패턴이던, 스프링 컨테이너와같은 싱글턴 컨테이너를 사용하던 하나의 객체 인스턴스를 공유하며 사용할때는 해당 객체 인스턴스의 멤버변수가 상태 유지하지않도록, 클라이언트에 의존적이지 않도록 설계하는것이 정말정말 중요하다.
