# 목차

1. 스프링이 뭐야?
2. 좋은 객체 지향 설계란?
3. 스프링 컨테이너, 스프링빈?
4. 싱글톤?
5. 컴포넌트 스캔방식?

# 요약

1. 스프링이란
   쉽게말해 자바언어의 특징인 객체지향의 특징을 더 잘 살리게 도와주는 프레임워크이다. 즉, 좋은 객체지향 어플리케이션을 만들도록 도와주는 프레임워크

2. 좋은 객체지향 설계란?
   구현- 역할을 나누어 설계하는것, 실제 사용하는 클라이언트코드(실행코드)는 역할에만 의존하고 구현체는 몰라야한다.! 이래야 변경에 유리한 유연한 코드설계가 가능한것. 이것은 다형성과 인터페이스로써 가능한것.
   추가로 이것만으로 SOLID원칙을 다 지키지못함(DIP, OCP)그래서 관심사를 분리해서 추상화에만 의존하게 하는것이 완전좋다.
   여기에 스프링을 도입해서 스프링 컨테이너와 빈의 개념을 이용한다. 그러면 싱글톤으로도 유지가능하고 좋다.

3. 스프링 컨테이너 스프링빈?
   스프링 컨테이너는 스프링빈 저장소를 가지고있고 싱글턴 컨테이너로 기본적으로 스프링 빈을 싱글톤으로 유지하고있다. 이는 싱글톤 패턴을 도입하지않고도 싱글톤으로 유지할수있는 기가믹한 기능이다.

4. 싱글톤?
   싱글톤은 객체 인스턴스 하나만가지고 해당 객체를 공유하는 객체를 의미한다. 이를 통해 메모리낭비를 줄일수있는 장점이있지만 이러한 공유변수를 이용할땐 stateful한 필드를 사용하면 안된다. 클라이언트가 변경할우려가있는 멤버변수를 이용하면 큰일난다.

5. 컴포넌트 스캔방식?
   스프링 컨테이너에서 `@Bean`으로 스프링 빈을 나열하며 스프링빈등록했지만 자동으로 스프링빈을 등록하는 방법인 컴포넌트 스캔방식이있따. 이는 `@ComponentScan`애너테이션이 붙은 클래스를 기전으로 탐색위치가 default라면 해당 클래스가 있는 패키지 포함 하위 패키지를 탐색하며 `@Component`애너테이션이 붙은 클래스를 스프링빈으로 자동으로 등록한다. 이때, 수동으로 스프링 빈 등록할때 스프링 빈간의 의존관계를 설정을 통해 주입했지만 컴포넌트 스캔방식에선 `@Autowired`로 자동의존관계 주입을 이용한다. 추가로 스프링 부트의 시작 설정정보인 `@SpringBootApplication`내에 `@ComponentScan`이있어서 해당 패키지를 시작으로 컴포넌트 스캔으로 `@Component`가있는 클래스를 스프링빈으로 자동등록한다. 그래서 내가 스프링 부트를 이용해 스프링 MVC로 게시판만들때 뭐딱히 `@ComponentScan`적지않아도 알아서 컴포넌트 스캔방식으로 스프링빈등록되었었는데 그게 `@SpringBootApplication`에서 동작하였기 때문이다. 추가로~!!!! `@SpringBootApplication`에너테이션은 내부적으로 ApplicationContext를 생성한다. 그래서 또 스프링 컨테이너를 굳이 만들지않아도 스프링부트를 이용할땐 바로바로 컴포넌트 스캔방식으로 등록된 스프링빈이 `@SpringBootApplication`에의해 만들어진 ApplicationContext(스프링 컨테이너)에 등록이 딱딱 되어지는 거였다.

# 특히 알게된것

- 스프링 부트 쓸떄 `@SpringBootApplication`에너테이션 클래스는 `@ComponentScan`을 내부적으로 가지고있고 해당 패키지를 기준으로 컴포넌트 스캔 탐색이 시작되는 것이였따. 그래서 스프링 부트 이용하면 `@ComponentScan`을 따로 이용하지않았던것
- 스프링 부트 쓸때 `@SpringBootApplication`에너테이션 클래스는 내부적으로 ApplicationContext(스프링 컨테이너)를 생성한다는 것이다. 우리는 계속 스프링 컨테이너를 직접적으로 생성하는데 스프링 부트를 이용하면 내부적으로 자동으로 생성하기 때문에 자동으로 생성된 스프링 컨테이너(ApplicationContext)에 컴포넌트 스캔방식으로등록된 스프링빈이 등록이 되어져있는 것이였다..
