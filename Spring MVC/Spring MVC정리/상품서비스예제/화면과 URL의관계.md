# 상품을 등록하고 상품상세화면으로 내부호출이되는데(뷰템플릿이 호출된다는 의미임. URL이 리다이렉트로 다시요청온다는 의미가아님. 서버 내부적으로만 다시 새로운 뷰 템플릿을 응답한다는 의미임.) 나는 상품상세화면으로 리다이렉트 되야하는줄알았다. 그러나 수업에선 상품을 등록하면 상품상세화면 뷰템플릿을 응답하긴하지만 URL은 그대로 /basic/items/add .. 나한텐 충격

- 그러나 곰곰히 생각해보니 일리가있다생각함.
- 상품 상세화면은 단순히 상품의 상세한 정보를 알고싶은거고 우리가 서버 내부호출로 새로 응답한 뷰템플릿은 상품을 등록하고잘등록되었나 확인하는 용도이다. 그럼 URL이 굳이 /baisc/items/{itemId}일 필요가 없다생각함.

# @ModelAttribute의 생략. 생략 생략...

- 솔직히 너무 생략이많아서 어렵다. 어짜피 이건 며칠 지나면 까먹을거같으나 그래도 적어보자.

- `@ModelAttribute`로 파라미터요청을 받으면 객체로 받는건 안다. 그런데 이번에 안사실은 다시 모델에 데이터를 넣어서 뷰에전달하는 역할도 한다는것이다. 그땐 규칙이조금있는데 `@ModelAttribute("item") Item item`은 `model.addAttribute("item", item)`의 역할도 한다는 사실이다. 이건 처음알았다. 파라미터 요청을 받는데 이름이 왜 `ModelAttribute`일까 ? 라는 생각은 했었는데 조금 이해가되는부분이다. 그런데 또 생략할수있다. 이건좀이해안되는데.. 아무튼 ("item")으로 모델 key값을 지정하는 부분을 생략할수있다. 생략하면 스프링 MVC는 클래스이름 첫글자 소문자로 바꾼녀석을 모델의 key로 넣어서 데이터를 넣는단다. 이건 좀 오바인거같다. 그닌까 `@ModelAttribute Item item`의 클래스이름이 Item이닌까 첫글자 I를 소문자 i로바꿔서 `model.addAttribute("item", item)`으로 넣는다고한다. 이건 사실 너무 자잘한부분이라 엄청 숙달되야 능수능란하게 사용할거같다. 근데 더충격적인건 `@ModelAttribute`자체도 생략가능하다는것! (사실 이건 `@RequestParam`과같이 생략가능하다는걸알고있었는데 이전 생략 가능함을 듣고 들으니 좀 복잡해진거같다.)

즉 완전히 다생략하면

```
    @PostMapping("/add")
    public String addItemV4(Item item){ // @ModelAttribute자체도 생략할수있음.
        itemRepository.save(item);
        return "basic/item";
    }
```

- 이런식으로 변하는데 처음보는사람은 `@ModelAttribute`자체가없으니 굉장히 혼동될거라생각함. 그게나긴한데..
- 아무튼 중요한건 `@ModelAttribute`는 단순히 파라미터요청 데이터를 객체로 받는것 뿐만아니라 모델에 데이터를 넣는 역할까지 담당한다.!!라는것..

# 알게된 것

- 랜더링되는 뷰와 URL의 미묘한 관계가 존재한다는걸알았다. 항상 랜더되는 페이지에맞게 URL이 설정되야하는건 아니란걸알았다.
- `@ModelAttribute`는 단순히 파라미터 요청 데이터를 객체로받는것 뿐만아니라 모델에 데이터를 담는 역할까지 한다는 걸알았고 적절한 단어의 조합으로 생략을 할수있다는걸 배웠다.
- 추가로 같은 URL요청이더라고 HTTP 메서드에 따라서 다르게 요청매핑된다는 사실은 이미 알고있었으나 이 방법은 되게 유용하다는 사실을 알게되었다. 예를들면 `/add` URL요청에 대한 GET과 이와같은 URL요청에대한 POST요청은 다른 메서드로 구분해서 쉽게 컨트롤러로직을 작성할수있다는 것이다!
