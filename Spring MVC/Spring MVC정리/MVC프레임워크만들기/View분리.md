# 프론트 컨트롤러 서블릿의 도입의 한계.

- viewPath, JSP 포워딩하는 부분의 중복된 코드가있다.(form 컨트롤러, save 컨트롤러, list 컨트롤러에서)
- 이러한 중복을 줄이자.

- 이전에는 각 컨트롤러에서 바로 JSP를 포워딩함으로 이러한 문제가 생겼지만 하나의 계층을 더만들자. MyView라는 계층을 만들어서 각 컨트롤러들에서 포워딩하는 중복 코드를 없애보자.

- 각 컨트롤러가 구현할 인터페이스의 추상메서드는 void가 아닌 MyView클래스를 리턴하자.
- MyView클래스는 render라는 메서드가 있는데 이 메서드는 viewPath에 해당되는 dispatcher를 JSP로 포워딩하는 역할을함.

- 즉, 각 컨트롤러는 MyView 인스턴스를 (viewPath의 값을 초기화..) 리턴만한다.

- 그래서 프론트컨트롤러에서 해당 MyView인스턴스를 받아서 MyView의 render메서드를 호출해서 해당 viewpath의 JSP를 포워딩함.

- 그래서 JSP가 응답하게됨

# MyView로 포워딩하는 역할을 하는 클래스 생성 전

1. HTTP요청
2. 프론트 컨트롤러 서블릿에서 요청받고 각 컨트롤러 매핑정보를 생성
3. 해당 컨트럴로 호출
4. 해당 컨트롤러에서 바로 JSP포워딩
5. JSP 응답

# MyView로 포워딩하는 역할 하는 클래스 생성후

(각 컨트롤러가 구현할 인터페이스의 리턴타입이 MyView가됨, 즉 MyView의 인스턴스를 리턴함 . 각 컨트롤러는)

1. HTTP 요청
2. 프론트컨트롤러 서블릿에서 요청받고 각 컨트롤러 매핑정보생성(URI, 각 컨트롤러)
3. 컨트롤러호출
4. 컨트롤러는 MyView인스턴스 리턴(viewPath인 멤버변수 초기화한 상태의..)
5. 프론트컨트롤러에선 각 컨트롤러가 리턴한 MyView인스턴스의 메서드인 render함수 호출(이 메서드는 JSP포워딩함)
6. JSP 포워딩
7. JSP 응답

-> 구조는 복잡해졌따. 그러나 각 컨트롤러에서 포워딩하는 중복코드가 줄어들었다.

# 한계

- 아직 사용하지않는 request, response 객체를 넘기는등여러 한계까있음
- 모델을 제대로 사용하지 않았음
