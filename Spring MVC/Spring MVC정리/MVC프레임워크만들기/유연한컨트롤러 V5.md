# V4까지해서 개발자 입장에서 프론트컨트롤러 패턴 MVC 프레임워크를 쉽게 사용할수있도록 변경하였따.

- 그런데 V4나 V4의 프론트 컨트롤러 서블릿을 보면 요청이들어오는 URI와 해당 URI와 매핑되는 컨트롤를 저장하는 로직을 보면
  `private Map<String, ControllerV4> controllerMap = new HashMap<>();`

- 이러하다. 즉, ControllerV4에 맞는 인스턴스만 들어갈수있다. ControllerV3는 들어갈수없다는 말이다

- 이렇게 V3의 컨트롤러도 사용하고싶고 V4 컨트롤러도 사용할수 있는 방법은없을까? -> 어댑터 패턴의 등장

# 어댑터 패턴

- 다양한 종류의 컨트롤러를 사용하기위해 String을 반환하는 V4컨트롤러와 ModelView를 반환하는 V3컨트롤러를 둘다 사용하게하는 어댑터 패턴을 이용해보자.
- 말 그대로 어댑터는 110V를 220V로 바꾸어주듯이 개발자가 사용하고싶은 컨트롤러에 맞는 어댑트를 이용하여 해당 컨트롤러를 호출해보자.
- 이제부턴 컨트롤러가 아닌 handler라고하겠다.

# 어댑터 패턴 과정

1. 요청
2. 프론트 컨트롤러해서 매핑되는 핸들러 갖고있음
3. 해당 핸들러와 매핑되는 핸들러 어댑터를 갖고있음
4. 해당 핸들러 어댑터의 handle메서드를 통해서 해당 핸들러를 호출
5. 핸들러 어댑터에서 실제 핸들러(MemberFormControllerV3, MemberFormControllerV4)를 호출.(전과 다른건 프론트 컨트롤러 서블릿에서 컨트롤러를 호출하는 것과는 다르게 핸들러 어댑터를 통해서 해당 컨트롤러를 호출함.) (여기서 중요한건 해당 컨트롤러가 리턴한느 값이 ModelView가 아니여도 어댑터에서 ModelView를 만들어주는 어댑터역할을 하는 것이중요.. V5 프론트 컨트롤러 서블릿에선 ModelView로 결과를 받기때문.)
6. ModelView를 프론트 컨트롤러로 반환
7. ViewResolver로 물리적인 이름 반환
8. MyView의 render호출
9. JSP 응답
