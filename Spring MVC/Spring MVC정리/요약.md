1. WebServer vs WAS
2. 멀티 쓰레드
3. Spring boot
4. Servlet
5. JSP
6. Servlet JSP MVC 패턴적용
7. Front Controller패턴
8. Spring MVC
9. Spring MVC 기능

# WebServer vs WAS

- 웹서버는 단순히 정적인 리소스를 서버에 가지고있다가 응답해주는 서버를 말한다.
- nginx가있다.
- WAS는 Web Application Server로 서버에서 비즈니스로직을 통해 동적으로 HTML을 만들어서 웹브라우저에 내려주는 서버를 말한다.
- tomcat이있다.
- 웹서버와 WAS를 앞뒤로 설정해서 웹서버에서는 정적인 리소스에 대해서만, WAS에서는 코드를통한 동적인 리소르를 내려주는 역할을 맡게하면 서버의 부담을 줄일수 있다.

# 멀티 쓰레드

- WAS(tomcat)는 멀티쓰레드를 지원한다.
- 쓰레드풀에 있는 쓰레드를 사용하고 다시 쓰레드풀에 반환하는형태로사용한다.
- 개발자는 쓰레드풀에 몇개의 쓰레드가 존재할수있는지 설정하는것이 중요하다.
- 멀티쓰레드에선 공유 자원을 사용하는데 조심해야한다. ex)싱글톤 객체 (servlet같은)

# Spring boot

- Spring boot는 톰캣과같은 WAS가 내장되어있다.
- Spring의 복잡한 설정을 자동으로 해준다.

# Servlet

- 개발자가 비즈니스로직에만 집중할수있도록 도와준다.
- Servlet을 지원하는 WAS(톰캣)은 Servlet 컨테이너라고도 하며 Servlet 컨테이너 내에는 Servlet객체가 존재한다. 이는 싱글톤으로 존재한다.
- 웹브라우저로부터 요청이 들어오면 WAS는 request, response객체를 만들고 서블릿 객체에게 전달하면 서블릿 객체는 HttpServletREquest, HttpServletResponse로 받고 개발자는 해당 객체들을 사용만하면된다.
- 즉 서블릿은 요청메시지를 파싱해주고 응답 메시지를 쉽게 만들어준다.

# JSP

- 뷰 기능에 특화된 뷰 템플릿이다.

# servlet과 JSP를 이용한 MVC패턴

- Servlet만으로, 혹은 JSP만으로 하나의 웹어플리케이션을 만드려고하면 너무 한파일에 많은 코드가있어 유지보수가 어렵고 변경의 라이프사이클이 달라 유지보수가 너무너무힘들다. 그리고 SErvlet은 자바를 통한 비즈니스로직에, JSP는 뷰에 적합한 기술이다.. 그래서 MVC패턴을 적용하자.
- MVC패턴은 Controller, Model, View로이루어져있고 Controller는 웹브라우저로부터의 요청을 받는 부분을의미한다. 받는동시에 비즈니스로직을 처리할수도있지만 이는 컨트롤러가 너무많은 기능을하는것으로 Controller Service Repository로 또 세분화하여 관심사를 분리하곤한다. 이렇게 컨트롤러는 웹브라우저로부터 요청을 받고 비즈니스로직을 실행하거나 호출하고 Model에 데이터를 넣고 View를 호출한다.
- Model에는 단순히 컨트롤러에서 준 데이터를담고있고 뷰는 이 모델을 통해서 데이터를 꺼내서 사용한다. 왜 굳이 모델이 필요할까? 라는생각은 뷰를 중심으로 생각해보면된다. 뷰는 단순히 화면 렌더링에만 집중할수있게 하는 부분인데 모델이없다면 컨트롤러로부터 데이터를 받아야하므로 컨트롤러의 코드를 알아야한다. 모델을 통해서 완전하게 뷰와 컨트롤러는 관심을 분리해 책임을 명확하게 할수있게된다.
- View는 단순히 모델에서 데이터를 꺼내서 화면을 렌더링하는데 집중한다.
- 그러나 MVC패턴을 적용해도 공통의 기능을 처리하는데 어려움이있다. 그래서 프론트컨트롤러 패턴을 이용하자.

# 프론트컨트롤러 패턴

- 웹브라우저로부터 요청을 받는 입구를 하나로 만드는 패턴이다.
- 웹브라우저로부터 요청을 서블릿으로 받는 이 컨트롤러를 프론트 컨트롤러라고한다.
- 프론트 컨트롤러에서 공통의 기능을 처리하고 각 컨트롤러를 호출하며 실행되는 매커니즘으로 동작하게끔 만들어보자.
- 그렇게하기 위해선 프론트 컨트롤러 서블릿!(웹브라우저로부터는 서블릿으로 받아야하므로 프론트 컨트롤러는 서블릿이다.)에서 요청에 맞게 컨트롤러를 호출해야하므로 웹브라우저로부터 요청을 받은뒤 매핑정보를통해서 컨트롤러를 호출한다. - v1
- 그런데 프론트컨트롤러 서블릿이 호출한 각 컨트롤러는 뷰를 랜더링하는 공통의 로직이있기에 뷰를 랜더링하는 부분을 클래스로 따로 분리한다 -v2
- 각 컨트롤러는 서블릿을 사용하지않기에 서블릿 종속성을 없앤다. 동시에 서블릿 종속성을 없애므로 서블릿을 통해서 모델에 데이터를 못넣기에 새로 모델을 담을수있는 Model클래스를 만든다. 추가로 랜더링할 view의 이름을 물리적인 이름을 반환하지말고 논리적인 이름을 반환하여 프론트컨트롤러 서블릿에서 ViewResolver라는 메서드를 통해서 물리적인이름으로 변경한뒤 뷰를 랜더링하도록 한다. - v3
- 컨트롤러마다 모델을 만들지말고 프론트컨트롤러 서블릿에서 모델을 만들어 전달하는 방식으로 변경한다. 이는 개발자로하여금 더 편하게 개발할수있게 도와줄것이다. - v4
- 여러 버전의 컨트롤러를 사용하기위해 어댑터 패턴을 이용한다. 흐름은 요청을 받으면 요청과 매핑된 컨트롤러를 가져오고 해당 컨트롤러의 어댑터를 가져온다. 해당 어댑터를 통해서 컨트롤러를 실행하는 흐름이다. 이를 통해 유연한 컨트롤러를 만들었따. - v5

# 스프링 MVC

- 위에서 만든 프론트 컨트롤러 패턴 프레임워크가 스프링 MVC이다. 프론트컨트롤러 서블릿이 DispatcherServlet이다.
- 스프링 MVC에서의 핸들러매핑은 우선순위가 존재해서 RequestMappingHanlerMapping -> Bean ~~순으로 컨트롤러를 찾는다.
- 뷰리졸버는 설정에서 prefix, suffix를 추가하여 논리적인 이름을 물리적인 이름으로변경해준다. 타임리프같은 경우는 타임리프 전용 뷰리졸버가 존재한다.

# 스프링 MVC 기능

## 요청매핑

- 웹브라우저의 요청을 매핑할수있는 `RequestMapping`이존재한다. 요청과매핑된 메서드는 호출이되는 형태로 이루어진다. 다양한 설정들을 제공하며 자주사용하는 PathVariable 경로변수도 사용할수있다. 추가로 HttpMethod에 따른 매핑도 가능한데 이는 축약 어노테이션인 `GetMapping, PostMapping`등이 존재한다.

## 헤더

- 요청의 헤더를 검색하기 위해선 `RequestHeader`, `Locale` 등이 존재한다. 바로 파라미터에서 받아서 사용하면된다.

## 웹브라우저에서 서버로 데이터전달

- 위 경우는 총세가지가있는데 Get으로 쿼리파라미터전달과, Post방식으로 HTML FOrm방식, 그리고 HTTP API(요청 바디에 text나 json전달)방식이있다.
- 첫번쨰나 두번째는 모두 쿼리파라미터 형식으로 데이터를 전달하기에 `@RequestParam`이나 `@ModelAttribute`를통해서 데이터를 받을수있다. 생략도가능한데 primitive나 단순한타입이면 `@RequestParam`, 타입이 클래스로 받으면 `@ModelAttribute`로 받을수있다. 추가로 `@ModelAttribute`는 바로 객체로 받을수있게 도와주는데 이기능 말고도 모델에 데이터를 담는 기능도 제공해준다.
- 세번째인 HTTP API방식은 요청 바디에 데이터나 json이 있을 때를 말하는데 `@RequestBody`로 바로 바디의 데이터를 읽을수있고 혹은 `HttpEntity`, 해당 자식`RequestEntity`를 통해서 바디의 데이터를 바로꺼낼수있다. 추가로 이 방식은 `@RequestBody`로 요청 데이터를 받거나 `HttpEntity, RequestEntity`로받으면 HTTP 메시지 컨버터를 통해서 파라미터의 타입과 요청 헤더 (Content-type - 표현 형식)를 보고 text를 받으면 적절히 형변환해서 받고 json을받으면 객체로 자동으로 받도록 도와준다.

## 웹서버에서 웹브라우저로 데이터전달

- 위 경우도 세가지이다. 정적인 리소스를 내려주거나, 동적인 HTML(타임리프 같은 뷰템프릿)을 내려주거나, HTTP API방식(응답 바디에 데이터, text, json넣어서)이있다. 정적인 리소스는 스프링의 경로가 정해져있다. 해당 경로에 html파일을 넣으면 자동으로 내려주고 뷰탬플릿도 `template`경로에 넣어주면된다. 추가로 이 경우는 `@Controller`가 클래스레벨에있고 컨트롤러 메서드가 String을 반환하면 viewResolve에 의해 논리이름을 물리이름으로 변경하여 해당 뷰템플릿을 내려준다. HTTP API방식은 `@ResponseBody`를 이용하거나 `HttpEntity`혹은 해당 자식`ResponseEntity`로 데이터를 내려주는 것이다. 이 방식또한 요청데이터 HTTP API방식과 같이 HTTP 메시지 컨버터를 통해서 반환타입이 `@ResponseBody`이거나 `HttpEntity`이면 메시지컨버터가 동작해서 타입과, 요청 헤더 Accept를 통해서 어떤방식으로 바디에 데이터를 넣어서 응답할지를 정하고 자동으로 변경해준다. 예를들면 객체를 반환하고 Accept가 application/json이면 json으로 넣어서 내려준다. 자동으로! 되게편하다.

## 추가로

- requestMappingHandlerMapping은 스프링 MVC에서 우선순위가 가장높은 핸들러 매핑이다. 스프링 MVC는 거의 99프로 애너테이션 기반 컨트롤러를 사용하는데 너무편해서 사용한다. 클래스레벨에 `@Controller`, `@RequestMapping`이있고 스프링빈으로 등록되어있으면 `requestMappingHandlerMapping`이 애너테이션 기반 컨트롤러임을 알고 해당 컨트롤러를 사용한다.
